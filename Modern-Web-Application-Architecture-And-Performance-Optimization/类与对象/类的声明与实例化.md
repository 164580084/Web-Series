[![章节头]("https://parg.co/UG3")](﻿https://parg.co/bxN) 
 - [静态方法](#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95) 


[14.5.14 Runtime Semantics: ClassDefinitionEvaluation](http://www.ecma-international.org/ecma-262/6.0/#sec-runtime-semantics-classdefinitionevaluation) 


```
class C {
    constructor() {
        // Use inner name C to refer to class
        console.log(`constructor: ${C.prop}`);
    }
    logProp() {
        // Use inner name C to refer to class
        console.log(`logProp: ${C.prop}`);
    }
}
C.prop = 'Hi!';


const D = C;
C = null;


// C is not a class, anymore:
new C().logProp();
    // TypeError: C is not a function


// But inside the class, the identifier C
// still works
new D().logProp();
    // constructor: Hi!
    // logProp: Hi!
```
```
class A {
  say() {
    console.log(A);
  }
}


var B = A;
A = null;


var a = new B();
a.say();


let C = function() {};


C.prototype.say = function() {
  console.log(C);
};


var D = C;
C = null;


var c = new D();
c.say();


// [Function: A]
// null
```


## 静态方法
```
class Obj {

  static myMethod(msg) {

    console.log('static', msg);

  }

  myMethod(msg) {

    console.log('instance', msg);

  }

}

Obj.myMethod(1); // static 1

var instance = new Obj();

instance.myMethod(2); // instance 2

```
Access Self Method

```
class A {

  constructor( input ) {

    this.tight = A.getResult( input )

    //this.tight = this.constructor.getResult( input )

  }

  

  

  static getResult( input ) {

    return input * 2

  }

}

let instanceA = new A( 4 );

console.log( "A.tight", instanceA.tight );  //A.tight 8

```
Remark

```
this.tight = this.constructor.getResult( input )

```
is as same as

```
this.tight = A.getResult( input )

```

